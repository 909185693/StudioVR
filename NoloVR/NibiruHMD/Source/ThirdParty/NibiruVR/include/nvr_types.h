/* Copyright 2016 Nibiru Inc. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#ifndef VR_NVR_CAPI_INCLUDE_NVR_TYPES_H_
#define VR_NVR_CAPI_INCLUDE_NVR_TYPES_H_

#include <stdbool.h>
#include <stdint.h>

#if defined( ANDROID )
#include <jni.h>
#elif defined( __cplusplus )
typedef struct _JNIEnv JNIEnv;
typedef struct _JavaVM JavaVM;
typedef class _jobject * jobject;
#else
typedef const struct JNINativeInterface * JNIEnv;
typedef const struct JNIInvokeInterface * JavaVM;
void * jobject;
#endif


#ifdef __cplusplus
extern "C" {
#endif

	/// An enum for the left and right eye.
	typedef enum {
		NVR_LEFT_EYE = 0,
		NVR_RIGHT_EYE,
		NVR_NUM_EYES
	} nvr_eye;
  
	/// @}

	/// Version information for the Nibiru VR API.
	typedef struct nvr_version_ {
		int32_t major;
		int32_t minor;
		int32_t patch;
	} nvr_version;

	/// An integral 2D size. Used for render target sizes.
	typedef struct nvr_sizei {
		int32_t width;
		int32_t height;
	} nvr_sizei;

	/// An integral 2D rect. Used for window bounds in pixels.
	typedef struct nvr_recti {
		int32_t left;
		int32_t right;
		int32_t bottom;
		int32_t top;
	} nvr_recti;

	/// A floating point 2D rect. Used for field of view, and also for ranges
	/// in texture space. When used for a field of view, all angles are in positive
	/// degrees from the optical axis.
	typedef struct nvr_rectf {
		float left;
		float right;
		float bottom;
		float top;
	} nvr_rectf;

	///
	typedef struct nvr_init_info {
		int sdk_version;
		int init_result;
		int mesh_x;
		int mesh_y;
		int extraIParam;
		float extraFParam;
		char *extraData;
	} nvr_init_info;

	/// A floating point 2D vector.
	typedef struct nvr_vec2f {
		float x;
		float y;
	} nvr_vec2f;

	/// A floating point 3D vector.
	typedef struct nvr_vec3f {
		float x;
		float y;
		float z;
	} nvr_vec3f;

	/// A floating point 4x4 matrix.
	typedef struct nvr_mat4f { float m[4][4]; } nvr_mat4f;

	/// A floating point quaternion, in JPL format.
	/// We use this simple struct in order not to impose a dependency on a
	/// particular math library. The user of this API is free to encapsulate this
	/// into any math library they want.
	typedef struct nvr_quatf {
		/// qx, qy, qz are the vector component.
		float qx;
		float qy;
		float qz;
		/// qw is the linelar component.
		float qw;
	} nvr_quatf;

	/// A *monotonic system time* representation. On Android, this is equivalent to
	/// System.nanoTime(), or clock_gettime(CLOCK_MONOTONIC). If there is any doubt
	/// about how to get the current time for the current platform, simply use
	/// gvr_get_time_point_now().
	typedef struct nvr_clock_time_point {
		int64_t monotonic_system_time_nanos;
	} nvr_clock_time_point;

	/// A structure that ties together a region of a buffer, the field of view
	/// rendered into that region and a target eye index to define part of the
	/// user's field of view. The SDK implementation uses this information to
	/// transform the images generated by the app output into the final display that
	/// is sent to the screen.
	///
	/// A set of these structures will most often be generated by the API, via
	/// nvr_get_recommended_buffer_viewports() or
	/// nvr_get_screen_buffer_viewports(). However, the client may also customize
	/// these values via nvr_buffer_viewport_list_set(), constructing a custom
	/// nvr_buffer_viewport_list for use in the distortion pass.
	typedef struct nvr_buffer_viewport_ nvr_buffer_viewport;

	/// List of buffer viewports that completely specifies how to transform the
	/// frame's buffers into the image displayed on the screen.
	typedef struct nvr_buffer_viewport_list_ nvr_buffer_viewport_list;

	/// Specification of a pixel buffer. A pixel buffer can have color, depth and
	/// stencil attachments and mostly corresponds to the OpenGL concept of a
	/// framebuffer object. However, since there can be multiple such objects for
	/// each frame, we avoid calling them "framebuffers". Pixel buffers which are
	/// part of the currently acquired frame are immutable, i.e., they cannot be
	/// resized or otherwise reconfigured.
	typedef struct nvr_buffer_spec_ nvr_buffer_spec;

	/// Swap chain that contains some number of frames. Frames in the swap chain
	/// can be unused, in the process of being distorted and presented on the
	/// screen, or acquired and being rendered to by the application. The swap chain
	/// ensures that the most recent available frame is always shown and that the
	/// application never has to wait to render the next frame.
	typedef struct nvr_swap_chain_ nvr_swap_chain;

	/// A single frame acquired from the swap chain. Each frame is composed of one
	/// or more buffers, which are then lens distorted and composited into the final
	/// output. Buffers are identified by indices that correspond to the position
	/// of their gvr_buffer_spec in the list passed when constructing the swap
	/// chain.
	typedef struct nvr_frame_ nvr_frame;

	/// @addtogroup types
	/// @{

	/// Constants that represent nvr error codes.
	typedef enum {
		NVR_ERROR_NONE = 0,
		NVR_ERROR_CONTROLLER_CREATE_FAILED = 2,
		NVR_ERROR_NO_FRAME_AVAILABLE = 3,
	} nvr_error;

   
	/// Valid color formats for swap chain buffers.
	typedef enum {
		/// Equivalent to GL_RGBA8
		NVR_COLOR_FORMAT_RGBA_8888 = 0,
		/// Equivalent to GL_RGB565
		NVR_COLOR_FORMAT_RGB_565 = 1,
	} nvr_color_format_type;

	typedef enum {
		/// No depth or stencil buffer.
		NVR_DEPTH_STENCIL_FORMAT_NONE = 255,
		/// Equivalent to GL_DEPTH_COMPONENT16.
		NVR_DEPTH_STENCIL_FORMAT_DEPTH_16 = 0,
		/// Equivalent to GL_DEPTH_COMPONENT24.
		NVR_DEPTH_STENCIL_FORMAT_DEPTH_24 = 1,
		/// Equivlaent to GL_DEPTH24_STENCIL8.
		NVR_DEPTH_STENCIL_FORMAT_DEPTH_24_STENCIL_8 = 2,
		/// Equivalent to GL_DEPTH_COMPONENT32F.
		NVR_DEPTH_STENCIL_FORMAT_DEPTH_32_F = 3,
		/// Equivalent to GL_DEPTH_32F_STENCIL8.
		NVR_DEPTH_STENCIL_FORMAT_DEPTH_32_F_STENCIL_8 = 4,
		/// Equivalent to GL_STENCIL8.
		NVR_DEPTH_STENCIL_FORMAT_STENCIL_8 = 5,
	} nvr_depth_stencil_format_type;

	/// Types of asynchronous reprojection.
	typedef enum {
		/// Do not reproject.
		NVR_REPROJECTION_NONE = 0,
		/// Reproject in all dimensions.
		NVR_REPROJECTION_FULL = 1,
	} nvr_reprojection;
	 
	typedef struct
	{
		JavaVM *	Vm;					// Java Virtual Machine
		JNIEnv *	Env;				// Thread specific environment
		jobject		ActivityObject;		// Java activity object
	} nvrJava;

	typedef struct
	{
		// The Java VM is needed for the time warp thread to create a Java environment.
		// A Java environment is needed to access various system services. The thread
		// that enters VR mode is responsible for attaching and detaching the Java
		// environment. The Java Activity object is needed to get the windowManager,
		// packageName, systemService, etc.
		nvrJava				Java;

		// If not zero, then use this display for asynchronous time warp rendering.
		// Using EGL this is an EGLDisplay.
		unsigned long long	Display;

		// If not zero, then use this window surface for asynchronous time warp rendering.
		// Using EGL this can be the EGLSurface created by the application for the ANativeWindow.
		// Preferrably this is the ANativeWIndow itself (requires VRAPI_MODE_FLAG_NATIVE_WINDOW).
		unsigned long long	WindowSurface;

		// If not zero, then resources from this context will be shared with the asynchronous time warp.
		// Using EGL this is an EGLContext.
		unsigned long long	ShareContext;
	} nvrModeParms;

	/// @}

#ifdef __cplusplus
}  // extern "C"
#endif
#endif /* VR_NVR_CAPI_INCLUDE_NVR_TYPES_H_ */
